/*******************************************************************************
 * Copyright (c) 2010 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
package org.eclipse.scout.sdk.internal.test.operation.jdt.method;

import java.util.List;

import org.eclipse.core.runtime.CoreException;
import org.eclipse.jdt.core.Flags;
import org.eclipse.jdt.core.IJavaProject;
import org.eclipse.jdt.core.IMethod;
import org.eclipse.jdt.core.IType;
import org.eclipse.jdt.core.JavaCore;
import org.eclipse.jdt.core.Signature;
import org.eclipse.scout.nls.sdk.model.INlsEntry;
import org.eclipse.scout.nls.sdk.model.workspace.project.INlsProject;
import org.eclipse.scout.sdk.internal.test.AbstractSdkTestWithJdtTestProject;
import org.eclipse.scout.sdk.operation.jdt.icu.CompilationUnitNewOperation;
import org.eclipse.scout.sdk.operation.jdt.method.MethodNewOperation;
import org.eclipse.scout.sdk.operation.jdt.method.MethodOverrideOperation;
import org.eclipse.scout.sdk.operation.jdt.type.PrimaryTypeNewOperation;
import org.eclipse.scout.sdk.sourcebuilder.method.IMethodBodySourceBuilder;
import org.eclipse.scout.sdk.sourcebuilder.method.IMethodSourceBuilder;
import org.eclipse.scout.sdk.sourcebuilder.method.MethodBodySourceBuilderFactory;
import org.eclipse.scout.sdk.sourcebuilder.method.MethodSourceBuilder;
import org.eclipse.scout.sdk.sourcebuilder.method.MethodSourceBuilderFactory;
import org.eclipse.scout.sdk.sourcebuilder.type.TypeSourceBuilder;
import org.eclipse.scout.sdk.testing.SdkAssert;
import org.eclipse.scout.sdk.testing.TestWorkspaceUtility;
import org.eclipse.scout.sdk.util.signature.IImportValidator;
import org.eclipse.scout.sdk.util.signature.SignatureCache;
import org.eclipse.scout.sdk.util.type.MethodFilters;
import org.eclipse.scout.sdk.util.type.TypeUtility;
import org.eclipse.scout.sdk.workspace.type.ScoutTypeUtility;
import org.junit.Assert;
import org.junit.Test;

/**
 * <h3>{@link MethodNewOperationTest}</h3>
 *
 * @author Andreas Hoegger
 * @since 3.8.0 08.03.2013
 */
public class MethodNewOperationTest extends AbstractSdkTestWithJdtTestProject {

  @Test
  public void testSimpleMethod() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.MethodTest");
    String methodName = "simpleMethod";
    MethodNewOperation methodOp = new MethodNewOperation(methodName, declaringType);
    methodOp.setFlags(Flags.AccPublic);
    methodOp.setReturnTypeSignature(Signature.SIG_VOID);

    executeBuildAssertNoCompileErrors(methodOp);

    IMethod createdMethod = methodOp.getCreatedMethod();
    Assert.assertTrue(TypeUtility.exists(createdMethod));
    Assert.assertTrue(TypeUtility.exists(TypeUtility.getMethod(declaringType, methodName)));
    Assert.assertTrue(Flags.isPublic(createdMethod.getFlags()));
    Assert.assertFalse(Flags.isStatic(createdMethod.getFlags()));
    Assert.assertFalse(Flags.isFinal(createdMethod.getFlags()));
    Assert.assertEquals(createdMethod.getReturnType(), Signature.SIG_VOID);
  }

  @Test
  public void testStaticMethod() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.MethodTest");
    String methodName = "staticMethod";
    MethodNewOperation methodOp = new MethodNewOperation(methodName, declaringType);
    methodOp.setFlags(Flags.AccPublic | Flags.AccStatic | Flags.AccFinal);
    methodOp.setReturnTypeSignature(Signature.createTypeSignature(String.class.getName(), true));
    methodOp.setMethodBodySourceBuilder(MethodBodySourceBuilderFactory.createAutoGeneratedMethodBody());

    executeBuildAssertNoCompileErrors(methodOp);

    IMethod createdMethod = methodOp.getCreatedMethod();
    Assert.assertTrue(TypeUtility.exists(createdMethod));
    Assert.assertTrue(TypeUtility.exists(TypeUtility.getMethod(declaringType, methodName)));
    Assert.assertTrue(Flags.isPublic(createdMethod.getFlags()));
    Assert.assertTrue(Flags.isStatic(createdMethod.getFlags()));
    Assert.assertTrue(Flags.isFinal(createdMethod.getFlags()));
    Assert.assertEquals(createdMethod.getReturnType(), Signature.createTypeSignature("String", false));
  }

  @Test
  public void testMethodWithException() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.MethodTest");
    String methodName = "methodThrowsException";
    MethodNewOperation methodOp = new MethodNewOperation(methodName, declaringType);
    methodOp.setFlags(Flags.AccPublic);
    methodOp.setReturnTypeSignature(Signature.createTypeSignature(List.class.getName(), true));
    methodOp.setMethodBodySourceBuilder(MethodBodySourceBuilderFactory.createAutoGeneratedMethodBody());
    methodOp.addExceptionSignature(Signature.createTypeSignature(CoreException.class.getName(), true));

    executeBuildAssertNoCompileErrors(methodOp);

    IMethod createdMethod = methodOp.getCreatedMethod();
    Assert.assertTrue(TypeUtility.exists(createdMethod));
    Assert.assertTrue(TypeUtility.exists(TypeUtility.getMethod(declaringType, methodName)));
    Assert.assertTrue(Flags.isPublic(createdMethod.getFlags()));
    Assert.assertFalse(Flags.isStatic(createdMethod.getFlags()));
    Assert.assertFalse(Flags.isFinal(createdMethod.getFlags()));
    Assert.assertEquals(createdMethod.getReturnType(), Signature.createTypeSignature("List", false));
  }

  @Test
  public void testOverrideMethod() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.TestForm.MainBox.SmartField");
    String methodName = "getConfiguredEnabled";
    IMethod methodToOverride = TypeUtility.findMethodInSuperclassHierarchy(declaringType, MethodFilters.getNameFilter(methodName));
    Assert.assertTrue(TypeUtility.exists(methodToOverride));
    MethodOverrideOperation methodOp = new MethodOverrideOperation(methodToOverride, declaringType);
    methodOp.setMethodBodySourceBuilder(MethodBodySourceBuilderFactory.createSimpleMethodBody("return false;"));

    executeBuildAssertNoCompileErrors(methodOp);

    IMethod createdMethod = methodOp.getCreatedMethod();
    Assert.assertTrue(TypeUtility.exists(createdMethod));
    Assert.assertTrue(TypeUtility.exists(TypeUtility.getMethod(declaringType, methodName)));
    Assert.assertEquals(methodToOverride.getFlags(), createdMethod.getFlags());
    Assert.assertEquals(methodToOverride.getReturnType(), createdMethod.getReturnType());
  }

  @Test
  public void testOverrideNlsTextMehtod() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.TestForm.MainBox.LabelField");
    String methodName = "getConfiguredLabel";
    INlsProject nlsProject = ScoutTypeUtility.findNlsProject(getSharedJavaProject());
    INlsEntry entry = nlsProject.getEntry("translatedStringFieldLabel");
    Assert.assertNotNull(entry);
    MethodOverrideOperation methodOverrideOp = new MethodOverrideOperation(methodName, declaringType);
    methodOverrideOp.setMethodBodySourceBuilder(MethodBodySourceBuilderFactory.createNlsEntryReferenceBody(entry));

    executeBuildAssertNoCompileErrors(methodOverrideOp);

    Assert.assertTrue(TypeUtility.exists(methodOverrideOp.getCreatedMethod()));
  }

  @Test
  public void testOverrideMethodWithGenericType() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.TestForm.MainBox.SmartField");
    String methodName = "execPrepareKeyLookup";
    IMethod methodToOverride = TypeUtility.findMethodInSuperclassHierarchy(declaringType, MethodFilters.getNameFilter(methodName));
    Assert.assertTrue(TypeUtility.exists(methodToOverride));
    MethodOverrideOperation methodOp = new MethodOverrideOperation(methodToOverride, declaringType);

    executeBuildAssertNoCompileErrors(methodOp);

    IMethod createdMethod = methodOp.getCreatedMethod();
    Assert.assertTrue(TypeUtility.exists(createdMethod));
    Assert.assertTrue(TypeUtility.exists(TypeUtility.getMethod(declaringType, methodName)));
    Assert.assertEquals(methodToOverride.getFlags(), createdMethod.getFlags());
    Assert.assertEquals(methodToOverride.getReturnType(), createdMethod.getReturnType());
    Assert.assertEquals(Signature.createTypeSignature(Long.class.getSimpleName(), false), createdMethod.getParameterTypes()[1]);
  }

  @Test
  public void testOverrideMethodWithGenericType2() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.TestForm.MainBox.SmartField");
    String methodName = "validateValueInternal";
    IMethod methodToOverride = TypeUtility.findMethodInSuperclassHierarchy(declaringType, MethodFilters.getNameFilter(methodName));
    Assert.assertTrue(TypeUtility.exists(methodToOverride));
    MethodOverrideOperation methodOp = new MethodOverrideOperation(methodToOverride, declaringType);
    methodOp.setMethodBodySourceBuilder(MethodBodySourceBuilderFactory.createAutoGeneratedMethodBody());

    executeBuildAssertNoCompileErrors(methodOp);

    IMethod createdMethod = methodOp.getCreatedMethod();
    Assert.assertTrue(TypeUtility.exists(createdMethod));
    Assert.assertTrue(TypeUtility.exists(TypeUtility.getMethod(declaringType, methodName)));
    Assert.assertEquals(methodToOverride.getFlags(), createdMethod.getFlags());
    Assert.assertEquals(Signature.createTypeSignature(Long.class.getSimpleName(), false), createdMethod.getParameterTypes()[0]);
    Assert.assertEquals(Signature.createTypeSignature(Long.class.getSimpleName(), false), createdMethod.getReturnType());
  }

  @Test
  public void testOverrideMethodWithGenericType3() throws Exception {
    IType declaringType = SdkAssert.assertTypeExists("jdt.test.client.TestForm.MainBox.SmartField");
    String methodName = "getConfiguredCodeType";
    IMethod methodToOverride = TypeUtility.findMethodInSuperclassHierarchy(declaringType, MethodFilters.getNameFilter(methodName));
    Assert.assertTrue(TypeUtility.exists(methodToOverride));
    MethodOverrideOperation methodOp = new MethodOverrideOperation(methodToOverride, declaringType);
    methodOp.setMethodBodySourceBuilder(new IMethodBodySourceBuilder() {
      @Override
      public void createSource(IMethodSourceBuilder methodBuilder, StringBuilder source, String lineDelimiter, IJavaProject ownerProject, IImportValidator validator) throws CoreException {
        source.append("return ").append(validator.getTypeName(Signature.createTypeSignature("jdt.test.shared.services.code.BlubberCodeType", true))).append(".class;");
      }
    });
    executeBuildAssertNoCompileErrors(methodOp);

    IMethod createdMethod = methodOp.getCreatedMethod();
    Assert.assertTrue(TypeUtility.exists(createdMethod));
    Assert.assertTrue(TypeUtility.exists(TypeUtility.getMethod(declaringType, methodName)));
    Assert.assertEquals(methodToOverride.getFlags(), createdMethod.getFlags());
    Assert.assertEquals("QClass<+QICodeType<*QLong;>;>;", createdMethod.getReturnType());
  }

  @Test
  public void testOverrideAnInterfaceMethod() throws Exception {
    IJavaProject clientProject = JavaCore.create(getProject("jdt.test.client"));
    Assert.assertTrue(TypeUtility.exists(clientProject));
    PrimaryTypeNewOperation typeOp = new PrimaryTypeNewOperation("ImplementationType", "jdt.test.client.method", clientProject);
    typeOp.addInterfaceSignature(Signature.createTypeSignature("jdt.test.client.method.IAnInterface", true));
    typeOp.setFlags(Flags.AccPublic);

    TestWorkspaceUtility.executeAndBuildWorkspace(typeOp);

    Assert.assertTrue(TypeUtility.exists(typeOp.getCreatedType()));

    MethodOverrideOperation doStuffOverrideOp = new MethodOverrideOperation("doStuff", typeOp.getCreatedType());
    executeBuildAssertNoCompileErrors(doStuffOverrideOp);

    Assert.assertTrue(TypeUtility.exists(doStuffOverrideOp.getCreatedMethod()));
    Assert.assertTrue(Flags.isPublic(doStuffOverrideOp.getCreatedMethod().getFlags()));
  }

  @Test
  public void testOverrideAnAbstractMethod() throws Exception {
    IJavaProject clientProject = JavaCore.create(getProject("jdt.test.client"));
    Assert.assertTrue(TypeUtility.exists(clientProject));
    PrimaryTypeNewOperation typeOp = new PrimaryTypeNewOperation("ImplementationTypeOfAbstractType", "jdt.test.client.method", clientProject);
    typeOp.setSuperTypeSignature(Signature.createTypeSignature("jdt.test.client.method.AnAbstractType", true));
    typeOp.setFlags(Flags.AccPublic);

    TestWorkspaceUtility.executeAndBuildWorkspace(typeOp);

    Assert.assertTrue(TypeUtility.exists(typeOp.getCreatedType()));
    MethodOverrideOperation doStuffOverrideOp = new MethodOverrideOperation("doStuff", typeOp.getCreatedType());
    executeBuildAssertNoCompileErrors(doStuffOverrideOp);
    Assert.assertTrue(TypeUtility.exists(doStuffOverrideOp.getCreatedMethod()));
    Assert.assertTrue(Flags.isPublic(doStuffOverrideOp.getCreatedMethod().getFlags()));
  }

  @Test
  public void testOverrideAnAbstractGenericMethod() throws Exception {
    IJavaProject clientProject = JavaCore.create(getProject("jdt.test.client"));
    Assert.assertTrue(TypeUtility.exists(clientProject));
    PrimaryTypeNewOperation typeOp = new PrimaryTypeNewOperation("ImplementationTypeWithGeneric", "jdt.test.client.method", clientProject);
    typeOp.setSuperTypeSignature(Signature.createTypeSignature("jdt.test.client.method.AnAbstractTypeWithGeneric<" + String.class.getName() + ">", true));
    typeOp.setFlags(Flags.AccPublic);

    executeBuildAssertNoCompileErrors(typeOp);

    Assert.assertTrue(TypeUtility.exists(typeOp.getCreatedType()));

    MethodOverrideOperation getValueOp = new MethodOverrideOperation("getValue", typeOp.getCreatedType());
    executeBuildAssertNoCompileErrors(getValueOp);
    Assert.assertTrue(TypeUtility.exists(getValueOp.getCreatedMethod()));
    Assert.assertTrue(Flags.isPublic(getValueOp.getCreatedMethod().getFlags()));
    MethodNewOperation setValueOp = new MethodNewOperation(MethodSourceBuilderFactory.createOverrideMethodSourceBuilder("setValue", typeOp.getCreatedType()), typeOp.getCreatedType());

    executeBuildAssertNoCompileErrors(setValueOp);

    Assert.assertTrue(TypeUtility.exists(setValueOp.getCreatedMethod()));
    Assert.assertTrue(Flags.isPublic(setValueOp.getCreatedMethod().getFlags()));
  }

  @Test
  public void testOverrideAMethodOfAnInterfaceSourceBuilder() throws Exception {
    IJavaProject clientProject = JavaCore.create(getProject("jdt.test.client"));

    // create an interface first
    CompilationUnitNewOperation ifcNewOp = new CompilationUnitNewOperation("ITestInterface.java", TypeUtility.getPackage(clientProject, "jdt.test.client.method"));
    TypeSourceBuilder ifcBuilder = new TypeSourceBuilder("ITestInterface");
    ifcBuilder.setFlags(Flags.AccPublic | Flags.AccInterface);
    MethodSourceBuilder msb = new MethodSourceBuilder("blub");
    msb.setReturnTypeSignature(Signature.SIG_VOID);
    msb.setFlags(Flags.AccInterface);
    ifcBuilder.addMethodSourceBuilder(msb);
    ifcNewOp.addTypeSourceBuilder(ifcBuilder);

    TestWorkspaceUtility.executeAndBuildWorkspace(ifcNewOp);
    TestWorkspaceUtility.assertNoCompileErrors();

    SdkAssert.assertTrue(TypeUtility.exists(ifcNewOp.getCreatedCompilationUnit()));
    SdkAssert.assertEquals(1, ifcNewOp.getCreatedCompilationUnit().getTypes().length);
    SdkAssert.assertTrue(TypeUtility.exists(ifcNewOp.getCreatedCompilationUnit().getTypes()[0]));

    // implement the method by overriding the interface method.
    CompilationUnitNewOperation icuNewOp = new CompilationUnitNewOperation("CompilationUnitIfcTestClass.java", TypeUtility.getPackage(clientProject, "jdt.test.client.method"));
    TypeSourceBuilder typeBuilder = new TypeSourceBuilder("CompilationUnitIfcTestClass");

    icuNewOp.addTypeSourceBuilder(typeBuilder);
    typeBuilder.addInterfaceSignature(SignatureCache.createTypeSignature(ifcNewOp.getCreatedCompilationUnit().getTypes()[0].getFullyQualifiedName()));
    typeBuilder.addMethodSourceBuilder(MethodSourceBuilderFactory.createOverrideMethodSourceBuilder(typeBuilder, "blub"));

    TestWorkspaceUtility.executeAndBuildWorkspace(icuNewOp);
    TestWorkspaceUtility.assertNoCompileErrors();

    SdkAssert.assertTypeExists("jdt.test.client.method.CompilationUnitIfcTestClass");
    SdkAssert.assertEquals(1, icuNewOp.getCreatedCompilationUnit().getTypes().length);
    SdkAssert.assertEquals(1, icuNewOp.getCreatedCompilationUnit().getTypes()[0].getMethods().length);
    SdkAssert.assertPublic(icuNewOp.getCreatedCompilationUnit().getTypes()[0].getMethods()[0]);
    SdkAssert.assertEquals(1, icuNewOp.getCreatedCompilationUnit().getTypes()[0].getSuperInterfaceNames().length);
  }

  @Test
  public void testOverrideAnAbstractGenericMethodInOneOp() throws Exception {
    IJavaProject clientProject = JavaCore.create(getProject("jdt.test.client"));
    Assert.assertTrue(TypeUtility.exists(clientProject));
    PrimaryTypeNewOperation typeOp = new PrimaryTypeNewOperation("ImplementationTypeWithGeneric1", "jdt.test.client.method", clientProject);
    typeOp.setSuperTypeSignature(Signature.createTypeSignature("jdt.test.client.method.AnAbstractTypeWithGeneric<" + String.class.getName() + ">", true));
    typeOp.setFlags(Flags.AccPublic);
    String getValueMethodName = "getValue";
    typeOp.addMethodSourceBuilder(MethodSourceBuilderFactory.createOverrideMethodSourceBuilder(typeOp.getSourceBuilder(), getValueMethodName));
    String setValueMethodName = "setValue";
    typeOp.addMethodSourceBuilder(MethodSourceBuilderFactory.createOverrideMethodSourceBuilder(typeOp.getSourceBuilder(), setValueMethodName));

    executeBuildAssertNoCompileErrors(typeOp);

    Assert.assertTrue(TypeUtility.exists(typeOp.getCreatedType()));

    IMethod getValueMethod = TypeUtility.getMethod(typeOp.getCreatedType(), getValueMethodName);
    Assert.assertTrue(TypeUtility.exists(getValueMethod));
    Assert.assertTrue(Flags.isPublic(getValueMethod.getFlags()));
    Assert.assertEquals("QList<QString;>;", getValueMethod.getReturnType());
    IMethod setValueMethod = TypeUtility.getMethod(typeOp.getCreatedType(), setValueMethodName);
    Assert.assertTrue(TypeUtility.exists(setValueMethod));
    Assert.assertEquals("QString;", setValueMethod.getParameterTypes()[0]);
  }
}
