/*******************************************************************************
 * Copyright (c) 2015 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 ******************************************************************************/
package org.eclipse.scout.sdk.core.sourcebuilder.method;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.atomic.AtomicLong;

import org.apache.commons.lang3.StringUtils;
import org.eclipse.jdt.internal.compiler.util.SuffixConstants;
import org.eclipse.scout.sdk.core.IJavaRuntimeTypes;
import org.eclipse.scout.sdk.core.model.api.Flags;
import org.eclipse.scout.sdk.core.model.api.IJavaEnvironment;
import org.eclipse.scout.sdk.core.model.api.IMethod;
import org.eclipse.scout.sdk.core.model.api.IType;
import org.eclipse.scout.sdk.core.signature.ISignatureConstants;
import org.eclipse.scout.sdk.core.signature.SignatureUtils;
import org.eclipse.scout.sdk.core.sourcebuilder.RawSourceBuilder;
import org.eclipse.scout.sdk.core.sourcebuilder.annotation.AnnotationSourceBuilderFactory;
import org.eclipse.scout.sdk.core.sourcebuilder.comment.CommentSourceBuilderFactory;
import org.eclipse.scout.sdk.core.sourcebuilder.compilationunit.CompilationUnitSourceBuilder;
import org.eclipse.scout.sdk.core.sourcebuilder.compilationunit.ICompilationUnitSourceBuilder;
import org.eclipse.scout.sdk.core.sourcebuilder.field.IFieldSourceBuilder;
import org.eclipse.scout.sdk.core.sourcebuilder.methodparameter.IMethodParameterSourceBuilder;
import org.eclipse.scout.sdk.core.sourcebuilder.methodparameter.MethodParameterSourceBuilder;
import org.eclipse.scout.sdk.core.sourcebuilder.type.ITypeSourceBuilder;
import org.eclipse.scout.sdk.core.sourcebuilder.type.TypeSourceBuilder;
import org.eclipse.scout.sdk.core.util.CoreUtils;
import org.eclipse.scout.sdk.core.util.Filters;
import org.eclipse.scout.sdk.core.util.IFilter;

/**
 * <h3>{@link MethodSourceBuilderFactory}</h3>
 *
 * @author Andreas Hoegger
 * @since 3.10.0 2013-03-07
 */
public final class MethodSourceBuilderFactory {

  private static final AtomicLong tempTypeCounter = new AtomicLong(0L);

  private MethodSourceBuilderFactory() {
  }

  public static IMethodSourceBuilder createConstructor(String typeName) {
    return createConstructor(typeName, Flags.AccPublic);
  }

  public static IMethodSourceBuilder createConstructor(String typeName, int flags, IMethodParameterSourceBuilder... parameters) {
    MethodSourceBuilder constructorSourceBuilder = new MethodSourceBuilder(typeName);
    constructorSourceBuilder.setFlags(flags);
    if (parameters != null) {
      for (IMethodParameterSourceBuilder p : parameters) {
        constructorSourceBuilder.addParameter(p);
      }
    }
    return constructorSourceBuilder;
  }

  public static List<IMethodSourceBuilder> createUnimplementedMethods(String superTypeSignature, Collection<String> superInterfacesSignatures, IJavaEnvironment env) {
    // build temporary type to calculate the fully resolved signatures
    IType tmpType = createTmpType(superTypeSignature, superInterfacesSignatures, env);

    List<IMethod> unimplementedMehtods = getUnimplementedMehtods(tmpType);
    if (unimplementedMehtods.isEmpty()) {
      return Collections.emptyList();
    }

    List<IMethodSourceBuilder> result = new ArrayList<>(unimplementedMehtods.size());
    for (IMethod method : unimplementedMehtods) {
      IMethodSourceBuilder unimplMethodBuilder = MethodSourceBuilderFactory.createOverride(method);
      unimplMethodBuilder.setBody(MethodBodySourceBuilderFactory.createAutoGenerated(unimplMethodBuilder));
      result.add(unimplMethodBuilder);
    }
    return result;
  }

  private static IType createTmpType(String superTypeSignature, Collection<String> superInterfacesSignatures, IJavaEnvironment env) {
    String typeName = "ScoutSdkTempDummyClass" + tempTypeCounter.incrementAndGet() + "__";
    ICompilationUnitSourceBuilder tmpCuBuilder = new CompilationUnitSourceBuilder(typeName + SuffixConstants.SUFFIX_STRING_java, "org.eclipse.scout.sdk.not.existing");
    ITypeSourceBuilder mainType = new TypeSourceBuilder(typeName);
    if (StringUtils.isNotBlank(superTypeSignature) && !ISignatureConstants.SIG_JAVA_LANG_OBJECT.equals(superTypeSignature)) {
      mainType.setSuperTypeSignature(superTypeSignature);
    }
    if (superInterfacesSignatures != null && !superInterfacesSignatures.isEmpty()) {
      for (String ifcSig : superInterfacesSignatures) {
        mainType.addInterfaceSignature(ifcSig);
      }
    }
    tmpCuBuilder.addType(mainType);

    IJavaEnvironment emptyCopy = env.unwrap().emptyCopy().wrap();
    StringBuilder newSrc = new StringBuilder(CoreUtils.createJavaCode(tmpCuBuilder, emptyCopy, "\n", null)); // create temporary source
    emptyCopy.registerCompilationUnitOverride(tmpCuBuilder.getPackageName(), tmpCuBuilder.getElementName(), newSrc);
    return emptyCopy.findType(mainType.getFullyQualifiedName());
  }

  private static List<IMethod> getUnimplementedMehtods(IType type) {
    if (type == null) {
      return Collections.emptyList();
    }

    Map<String, IMethod> abstractMethodIds = new HashMap<>();
    IFilter<IMethod> abstractMethodFilter = new IFilter<IMethod>() {
      @Override
      public boolean evaluate(IMethod element) {
        int flags = element.flags();
        return Flags.isAbstract(flags) || Flags.isInterface(flags) || Flags.isInterface(element.declaringType().flags());
      }
    };
    IFilter<IMethod> notAbstractMethodFilter = Filters.not(abstractMethodFilter);

    // collect all abstract and interface method IDs
    List<IMethod> abstractMethods = type.methods().withSuperTypes(true).withFilter(abstractMethodFilter).list();
    for (IMethod method : abstractMethods) {
      abstractMethodIds.put(SignatureUtils.createMethodIdentifier(method, true), method);
    }

    // remove all implemented methods
    List<IMethod> notAbstractMethods = type.methods().withSuperClasses(true).withFilter(notAbstractMethodFilter).list();
    for (IMethod method : notAbstractMethods) {
      if (!Flags.isPrivate(method.flags())) {
        abstractMethodIds.remove(SignatureUtils.createMethodIdentifier(method, true));
      }
    }

    return new ArrayList<>(abstractMethodIds.values());
  }

  private static IMethod getMethodToOverride(ITypeSourceBuilder typeSourceBuilder, IJavaEnvironment lookupContext, IFilter<IMethod> methodFilter) {
    IType tmpType = createTmpType(typeSourceBuilder.getSuperTypeSignature(), typeSourceBuilder.getInterfaceSignatures(), lookupContext);
    if (tmpType == null) {
      return null;
    }
    return tmpType.methods().withSuperTypes(true).withFilter(methodFilter).first();
  }

  public static IMethodSourceBuilder createOverride(ITypeSourceBuilder typeSourceBuilder, IJavaEnvironment lookupContext, String methodName) {
    return createOverride(typeSourceBuilder, lookupContext, methodName, null);
  }

  public static IMethodSourceBuilder createOverride(ITypeSourceBuilder typeSourceBuilder, IJavaEnvironment lookupContext, final String methodName, IFilter<IMethod> methodFilter) {
    IFilter<IMethod> filter = null;
    IFilter<IMethod> nameFilter = new IFilter<IMethod>() {
      @Override
      public boolean evaluate(IMethod element) {
        return element.elementName().equals(methodName);
      }
    };

    if (methodFilter == null) {
      filter = nameFilter;
    }
    else {
      filter = Filters.and(nameFilter, methodFilter);
    }

    IMethod methodToOverride = getMethodToOverride(typeSourceBuilder, lookupContext, filter);
    if (methodToOverride == null) {
      return null;
    }

    return createOverride(methodToOverride);
  }

  public static IMethodSourceBuilder createOverride(String methodName, IType declaringType) {
    IMethod methodToOverride = declaringType.methods().withSuperTypes(true).withName(methodName).first();
    if (methodToOverride == null) {
      return null;
    }
    return createOverride(methodToOverride);
  }

  /**
   * @param method
   * @return a new method source builder that overrides the parameter method
   */
  public static IMethodSourceBuilder createOverride(IMethod method) {
    final IMethodSourceBuilder builder = new MethodSourceBuilder(method);

    // add default body
    if (!(Flags.isInterface(method.declaringType().flags()) || Flags.isAbstract(method.flags()))) {
      builder.setBody(MethodBodySourceBuilderFactory.createSuperCall(builder, true));
    }

    // remove abstract & interface flag because we provide an implementation
    builder.setFlags(builder.getFlags() & ~Flags.AccAbstract & ~Flags.AccInterface);

    // reset comment
    builder.setComment(null);

    //Override annotation
    if (!method.annotations().withName(IJavaRuntimeTypes.Override).existsAny()) {
      builder.addAnnotation(AnnotationSourceBuilderFactory.createOverride());
    }

    return builder;
  }

  public static IMethodSourceBuilder createGetter(IFieldSourceBuilder fieldSourceBuilder) {
    return createGetter(fieldSourceBuilder.getElementName(), fieldSourceBuilder.getSignature());
  }

  public static IMethodSourceBuilder createGetter(String fieldName, String signature) {
    return createGetter(fieldName, signature, Flags.AccPublic, true);
  }

  public static IMethodSourceBuilder createGetter(String fieldName, String signature, int flags, boolean autoCreateBody) {
    StringBuilder methodName = new StringBuilder(CoreUtils.getGetterMethodPrefix(signature));
    methodName.append(getGetterSetterBaseName(fieldName));
    IMethodSourceBuilder getterBuilder = new MethodSourceBuilder(methodName.toString());
    getterBuilder.setReturnTypeSignature(signature);
    getterBuilder.setFlags(flags);
    getterBuilder.setComment(CommentSourceBuilderFactory.createDefaultGetterMethodComment(getterBuilder));
    if (autoCreateBody) {
      getterBuilder.setBody(new RawSourceBuilder(new StringBuilder("return ").append(fieldName).append(';').toString()));
    }
    return getterBuilder;
  }

  public static IMethodSourceBuilder createSetter(IFieldSourceBuilder fieldSourceBuilder) {
    return createSetter(fieldSourceBuilder.getElementName(), fieldSourceBuilder.getSignature());
  }

  public static IMethodSourceBuilder createSetter(String fieldName, String signature) {
    return createSetter(fieldName, signature, Flags.AccPublic, true);
  }

  private static String getGetterSetterBaseName(String fieldName) {
    StringBuilder sb = new StringBuilder(fieldName);
    if (sb.length() > 1 && sb.charAt(0) == 'm' && sb.charAt(1) == '_') {
      sb.delete(0, 2);
    }
    if (sb.length() > 0) {
      // ensure start with upper case
      sb.setCharAt(0, Character.toUpperCase(sb.charAt(0)));
    }
    return sb.toString();
  }

  public static IMethodSourceBuilder createSetter(String fieldName, String signature, int flags, boolean autoCreateBody) {
    return createSetter(fieldName, signature, flags, autoCreateBody, null);
  }

  public static IMethodSourceBuilder createSetter(String fieldName, String signature, int flags, boolean autoCreateBody, String paramNamePrefix) {
    String name = getGetterSetterBaseName(fieldName);

    IMethodSourceBuilder setterBuilder = new MethodSourceBuilder(new StringBuilder("set").append(name).toString());
    setterBuilder.setFlags(flags);
    setterBuilder.setReturnTypeSignature(ISignatureConstants.SIG_VOID);

    // parameter
    StringBuilder paramNameBuilder = new StringBuilder();
    if (StringUtils.isNotBlank(paramNamePrefix)) {
      paramNameBuilder.append(paramNamePrefix);
      paramNameBuilder.append(name);
    }
    else {
      paramNameBuilder.append(CoreUtils.ensureStartWithLowerCase(name));
    }
    String paramName = CoreUtils.ensureValidParameterName(paramNameBuilder.toString());
    setterBuilder.addParameter(new MethodParameterSourceBuilder(paramName, signature));

    // comment
    setterBuilder.setComment(CommentSourceBuilderFactory.createDefaultSetterMethodComment(setterBuilder));

    // body
    if (autoCreateBody) {
      StringBuilder body = new StringBuilder(fieldName);
      body.append(" = ");
      body.append(paramName);
      body.append(';');
      setterBuilder.setBody(new RawSourceBuilder(body.toString()));
    }
    return setterBuilder;
  }
}
