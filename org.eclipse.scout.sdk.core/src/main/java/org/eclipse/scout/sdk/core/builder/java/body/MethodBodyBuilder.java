/*
 * Copyright (c) 2017 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 */
package org.eclipse.scout.sdk.core.builder.java.body;

import java.util.Optional;
import java.util.stream.Stream;

import org.eclipse.scout.sdk.core.builder.ISourceBuilder;
import org.eclipse.scout.sdk.core.builder.java.IJavaBuilderContext;
import org.eclipse.scout.sdk.core.builder.java.comment.CommentBuilder;
import org.eclipse.scout.sdk.core.builder.java.comment.ICommentBuilder;
import org.eclipse.scout.sdk.core.builder.java.expression.ExpressionBuilder;
import org.eclipse.scout.sdk.core.generator.ISourceGenerator;
import org.eclipse.scout.sdk.core.generator.method.IMethodGenerator;
import org.eclipse.scout.sdk.core.generator.methodparam.IMethodParameterGenerator;
import org.eclipse.scout.sdk.core.model.api.IJavaEnvironment;
import org.eclipse.scout.sdk.core.util.Ensure;
import org.eclipse.scout.sdk.core.util.JavaTypes;

import static org.eclipse.scout.sdk.core.util.Ensure.newFail;

/**
 * <h3>{@link MethodBodyBuilder}</h3>
 *
 * @since 6.1.0
 */
public class MethodBodyBuilder<TYPE extends IMethodBodyBuilder<TYPE>> extends ExpressionBuilder<TYPE> implements IMethodBodyBuilder<TYPE> {

  private final IMethodGenerator<?, ? extends IMethodBodyBuilder<?>> m_surroundingMethod;
  private final ICommentBuilder<?> m_commentBuilder;

  protected MethodBodyBuilder(ISourceBuilder<?> inner, IMethodGenerator<?, ? extends IMethodBodyBuilder<?>> surroundingMethod) {
    super(inner);
    m_surroundingMethod = Ensure.notNull(surroundingMethod);
    m_commentBuilder = CommentBuilder.create(inner);
  }

  /**
   * Creates a new {@link IMethodBodyBuilder} wrapping the given inner {@link ISourceBuilder}.
   * <p>
   * If the context of the inner {@link ISourceBuilder} is an {@link IJavaBuilderContext}, this context and its
   * {@link IJavaEnvironment} is re-used. Otherwise a new {@link IJavaBuilderContext} without a {@link IJavaEnvironment}
   * is created.
   *
   * @param inner
   *          The inner {@link ISourceBuilder}. Must not be {@code null}.
   * @param surroundingMethod
   *          The {@link IMethodGenerator} the new {@link IMethodBodyBuilder} will belong to. Must not be {@code null}.
   * @return A new {@link IMethodBodyBuilder}.
   */
  public static IMethodBodyBuilder<?> create(ISourceBuilder<?> inner, IMethodGenerator<?, ? extends IMethodBodyBuilder<?>> surroundingMethod) {
    return new MethodBodyBuilder<>(inner, surroundingMethod);
  }

  @Override
  public TYPE appendAutoGenerated() {
    appendTodoAutoGeneratedMethodStub();
    if (needsReturnClause()) {
      returnClause().appendDefaultValueOf(surroundingMethod().returnType().get()).semicolon();
    }
    return currentInstance();
  }

  @Override
  public TYPE superClause() {
    return append(JavaTypes.SUPER);
  }

  @Override
  public TYPE returnClause() {
    return append("return ");
  }

  @Override
  public TYPE appendSuperCall() {
    return appendCallToSame(JavaTypes.SUPER);
  }

  @Override
  public TYPE appendCallToSame(CharSequence prefixSource) {
    if (needsReturnClause()) {
      returnClause();
    }
    if (prefixSource != null) {
      append(prefixSource);
    }

    boolean isConstructor = !surroundingMethod().returnType().isPresent();
    if (!isConstructor) {
      dotSign()
          .append(surroundingMethod().elementName().orElseThrow(() -> newFail("Cannot create a super call because method has no name.")));
    }

    Stream<ISourceGenerator<ISourceBuilder<?>>> parameterNames = surroundingMethod().parameters()
        .map(IMethodParameterGenerator::elementName)
        .map(nameOpt -> nameOpt.orElseThrow(() -> newFail("Parameter has no name")))
        .map(ISourceGenerator::raw);

    return parenthesisOpen()
        .append(parameterNames, null, ", ", null)
        .parenthesisClose()
        .semicolon();
  }

  @Override
  public TYPE appendParameterName(int index) {
    return append(surroundingMethod()
        .parameters()
        .skip(index)
        .findAny().orElseThrow(() -> newFail("Cannot find parameter with index {} in method {}", index, surroundingMethod().elementName().orElse(null)))
        .elementName().orElseThrow(() -> newFail("Parameter with index {} in method {} has no name.", index, surroundingMethod().elementName().orElse(null))));
  }

  @Override
  public TYPE returnClassLiteral(String type) {
    return returnClause().classLiteral(type).semicolon();
  }

  @Override
  public TYPE appendBlockCommentStart() {
    m_commentBuilder.appendBlockCommentStart();
    return currentInstance();
  }

  @Override
  public TYPE appendJavaDocStart() {
    m_commentBuilder.appendJavaDocStart();
    return currentInstance();
  }

  @Override
  public TYPE appendJavaDocLine(CharSequence comment) {
    m_commentBuilder.appendJavaDocLine(comment);
    return currentInstance();
  }

  @Override
  public TYPE appendBlockCommentEnd() {
    m_commentBuilder.appendBlockCommentEnd();
    return currentInstance();
  }

  @Override
  public TYPE appendBlockComment(String comment) {
    m_commentBuilder.appendBlockComment(comment);
    return currentInstance();
  }

  @Override
  public TYPE appendJavaDocComment(String comment) {
    m_commentBuilder.appendJavaDocComment(comment);
    return currentInstance();
  }

  @Override
  public TYPE appendTodo(CharSequence toDoMessage) {
    m_commentBuilder.appendTodo(toDoMessage);
    return currentInstance();
  }

  @Override
  public TYPE appendTodoAutoGeneratedMethodStub() {
    m_commentBuilder.appendTodoAutoGeneratedMethodStub();
    return currentInstance();
  }

  @Override
  public TYPE appendSingleLineComment(CharSequence msg) {
    m_commentBuilder.appendSingleLineComment(msg);
    return currentInstance();
  }

  @Override
  public boolean needsReturnClause() {
    Optional<String> returnType = surroundingMethod().returnType();
    return returnType.isPresent() && !JavaTypes._void.equals(returnType.get());
  }

  @Override
  public IMethodGenerator<?, ? extends IMethodBodyBuilder<?>> surroundingMethod() {
    return m_surroundingMethod;
  }
}
