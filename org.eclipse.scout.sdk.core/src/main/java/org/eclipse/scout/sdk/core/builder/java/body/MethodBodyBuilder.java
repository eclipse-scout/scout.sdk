/*
 * Copyright (c) 2010-2021 BSI Business Systems Integration AG.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * https://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *     BSI Business Systems Integration AG - initial API and implementation
 */
package org.eclipse.scout.sdk.core.builder.java.body;

import static org.eclipse.scout.sdk.core.util.Ensure.newFail;

import java.util.Optional;

import org.eclipse.scout.sdk.core.builder.ISourceBuilder;
import org.eclipse.scout.sdk.core.builder.java.IJavaBuilderContext;
import org.eclipse.scout.sdk.core.builder.java.comment.CommentBuilder;
import org.eclipse.scout.sdk.core.builder.java.comment.ICommentBuilder;
import org.eclipse.scout.sdk.core.builder.java.expression.ExpressionBuilder;
import org.eclipse.scout.sdk.core.builder.java.expression.IExpressionBuilder;
import org.eclipse.scout.sdk.core.generator.ISourceGenerator;
import org.eclipse.scout.sdk.core.generator.method.IMethodGenerator;
import org.eclipse.scout.sdk.core.generator.methodparam.IMethodParameterGenerator;
import org.eclipse.scout.sdk.core.model.api.IJavaEnvironment;
import org.eclipse.scout.sdk.core.util.Ensure;
import org.eclipse.scout.sdk.core.util.JavaTypes;

/**
 * <h3>{@link MethodBodyBuilder}</h3>
 *
 * @since 6.1.0
 */
public class MethodBodyBuilder<TYPE extends IMethodBodyBuilder<TYPE>> extends ExpressionBuilder<TYPE> implements IMethodBodyBuilder<TYPE> {

  private final IMethodGenerator<?, ?> m_surroundingMethod;
  private final ICommentBuilder<?> m_commentBuilder;

  protected MethodBodyBuilder(ISourceBuilder<?> inner, IMethodGenerator<?, ?> surroundingMethod) {
    super(inner);
    m_surroundingMethod = Ensure.notNull(surroundingMethod);
    m_commentBuilder = CommentBuilder.create(inner);
  }

  /**
   * Creates a new {@link IMethodBodyBuilder} wrapping the given inner {@link ISourceBuilder}.
   * <p>
   * If the context of the inner {@link ISourceBuilder} is an {@link IJavaBuilderContext}, this context and its
   * {@link IJavaEnvironment} is re-used. Otherwise a new {@link IJavaBuilderContext} without a {@link IJavaEnvironment}
   * is created.
   *
   * @param inner
   *          The inner {@link ISourceBuilder}. Must not be {@code null}.
   * @param surroundingMethod
   *          The {@link IMethodGenerator} the new {@link IMethodBodyBuilder} will belong to. Must not be {@code null}.
   * @return A new {@link IMethodBodyBuilder}.
   */
  public static IMethodBodyBuilder<?> create(ISourceBuilder<?> inner, IMethodGenerator<?, ?> surroundingMethod) {
    return new MethodBodyBuilder<>(inner, surroundingMethod);
  }

  @Override
  public TYPE appendAutoGenerated() {
    appendTodoAutoGeneratedMethodStub();
    surroundingMethodReturnTypeIfNotVoid().ifPresent(ret -> returnClause().appendDefaultValueOf(ret).semicolon());
    return thisInstance();
  }

  @Override
  public TYPE superClause() {
    return append(JavaTypes.SUPER);
  }

  @Override
  public TYPE returnClause() {
    return append("return ");
  }

  @Override
  public TYPE appendThis() {
    return append("this");
  }

  @Override
  public TYPE appendSuperCall() {
    return appendCallToSame(JavaTypes.SUPER);
  }

  @Override
  public TYPE appendCallToSame(CharSequence prefixSource) {
    if (needsReturnClause()) {
      returnClause();
    }
    if (prefixSource != null) {
      append(prefixSource);
    }

    var isConstructor = surroundingMethod().returnType().isEmpty();
    if (!isConstructor) {
      dot()
          .append(surroundingMethod().elementName(context()).orElseThrow(() -> newFail("Cannot create a super call because method has no name.")));
    }

    var parameterNames = surroundingMethod().parameters()
        .map(IMethodParameterGenerator::elementName)
        .map(nameOpt -> nameOpt.orElseThrow(() -> newFail("Parameter has no name")))
        .map(ISourceGenerator::raw);

    return parenthesisOpen()
        .append(parameterNames, null, ", ", null)
        .parenthesisClose()
        .semicolon();
  }

  @Override
  public TYPE appendParameterName(int index) {
    return append(surroundingMethod()
        .parameters()
        .skip(index)
        .findAny().orElseThrow(() -> newFail("Cannot find parameter with index {} in method {}", index, surroundingMethod().elementName().orElse(null)))
        .elementName().orElseThrow(() -> newFail("Parameter with index {} in method {} has no name.", index, surroundingMethod().elementName().orElse(null))));
  }

  @Override
  public TYPE returnClassLiteral(String type) {
    return returnClause().classLiteral(type).semicolon();
  }

  @Override
  public TYPE appendBlockCommentStart() {
    m_commentBuilder.appendBlockCommentStart();
    return thisInstance();
  }

  @Override
  public TYPE appendJavaDocStart() {
    m_commentBuilder.appendJavaDocStart();
    return thisInstance();
  }

  @Override
  public TYPE appendJavaDocLine(CharSequence comment) {
    m_commentBuilder.appendJavaDocLine(comment);
    return thisInstance();
  }

  @Override
  public TYPE appendBlockCommentEnd() {
    m_commentBuilder.appendBlockCommentEnd();
    return thisInstance();
  }

  @Override
  public TYPE appendBlockComment(String comment) {
    m_commentBuilder.appendBlockComment(comment);
    return thisInstance();
  }

  @Override
  public TYPE appendJavaDocComment(String comment) {
    m_commentBuilder.appendJavaDocComment(comment);
    return thisInstance();
  }

  @Override
  public TYPE appendTodo(CharSequence toDoMessage) {
    m_commentBuilder.appendTodo(toDoMessage);
    return thisInstance();
  }

  @Override
  public TYPE appendTodoAutoGeneratedMethodStub() {
    m_commentBuilder.appendTodoAutoGeneratedMethodStub();
    return thisInstance();
  }

  @Override
  public TYPE appendSingleLineComment(CharSequence msg) {
    m_commentBuilder.appendSingleLineComment(msg);
    return thisInstance();
  }

  @Override
  public boolean needsReturnClause() {
    return surroundingMethodReturnTypeIfNotVoid().isPresent();
  }

  protected Optional<String> surroundingMethodReturnTypeIfNotVoid() {
    return surroundingMethodReturnType()
        .filter(type -> !JavaTypes._void.equals(type));
  }

  @Override
  public Optional<String> surroundingMethodReturnType() {
    return surroundingMethod()
        .returnType()
        .flatMap(api -> api.apply(context()));
  }

  @Override
  public IMethodGenerator<?, ?> surroundingMethod() {
    return m_surroundingMethod;
  }

  @Override
  public TYPE appendNewInstance(CharSequence fqn, CharSequence variableName, ISourceGenerator<IExpressionBuilder<?>> constructorArg) {
    var newInstance = ref(fqn).space().append(variableName).equalSign().appendNew().ref(fqn).parenthesisOpen();
    if (constructorArg != null) {
      newInstance.append(constructorArg.generalize(ExpressionBuilder::create));
    }
    newInstance.parenthesisClose().semicolon();
    return newInstance;
  }
}
